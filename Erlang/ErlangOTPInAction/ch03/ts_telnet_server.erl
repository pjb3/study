%%%-------------------------------------------------------------------  
%%% @author Martin & Eric <erlware-dev@googlegroups.com> 
%%%  [http://www.erlware.org] 
%%% @copyright 2008 Erlware 
%%% @doc This module defines a server process that listens for incoming 
%%%      TCP connections and allows the user to execute commands via 
%%%      that TCP stream.                                             
%%%                                                                   
%%% @end                                                              
%%%-------------------------------------------------------------------
-module(ts_telnet_server). 

-behaviour(gen_server). 
 
%% API â€“ Functions users of this server will call                                                         
-export([ 
         start_link/1, 
         get_count/0, 
         stop/0 
        ]). 
 
%% gen_server callbacks                                                                                   
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, 
         terminate/2, code_change/3]). 
 
-define(SERVER, ?MODULE). 
 
-record(state, {port = 1055, lsock, request_count = 0}). 

%%%===================================================================                          
%%% API                                                                                         
%%%=================================================================== 
 
%%--------------------------------------------------------------------                          
%% @doc                                                                                         
%% Starts the server                                                                            
%%                                                                                              
%% @spec start_link(Port::integer()) -> {ok, Pid} | ignore | {error, Error}                     
%% @end                                                                                         
%%--------------------------------------------------------------------                          
start_link(Port) -> 
    gen_server:start_link({local, ?SERVER}, ?MODULE, [Port], []). 
 
%%--------------------------------------------------------------------                          
%% @doc fetch a count of the number of requests made to this server. 
%% @spec get_count() -> {ok, Count}                                                             
%% where                                                                                        
%%  Count = integer()                                                                           
%% @end                                                                                         
%%--------------------------------------------------------------------                          
get_count() -> 
    gen_server:call(?SERVER, get_count). 
 
%%--------------------------------------------------------------------                          
%% @doc stops the server.                                                                       
%% @spec stop() -> ok  
%% @end                                                                                         
%%--------------------------------------------------------------------                          
stop() -> 
    gen_server:cast(?SERVER, stop). 

%%-------------------------------------------------------------------- 
%% @private 
%% @doc 
%% Initiates the server. This callback maps to start and startlink. 
%% 
%% @spec init(Args) -> {ok, State} | 
%%                     {ok, State, Timeout} | 
%%                     ignore | 
%%                     {stop, Reason} 
%% @end 
%%-------------------------------------------------------------------- 
init([Port]) -> 
    {ok, LSock} = gen_tcp:listen(Port, [{active, true}]), 
    {ok, #state{port = Port, lsock = LSock}, 0}. 

%%-------------------------------------------------------------------- 
%% @private 
%% @doc 
%% Handling call messages. This callback maps to call 
%% 
%% @spec handle_call(Request, From, State) -> 
%%                                   {reply, Reply, State} | 
%%                                   {reply, Reply, State, Timeout} | 
%%                                   {noreply, State} | 
%%                                   {noreply, State, Timeout} | 
%%                                   {stop, Reason, Reply, State} | 
%%                                   {stop, Reason, State} 
%% @end 
%%-------------------------------------------------------------------- 
handle_call(get_count, _From, State) -> 
    {reply, {ok, State#state.request_count}, State}. 
 
%%-------------------------------------------------------------------- 
%% @private 
%% @doc 
%% Handling cast messages. This callback maps to cast. 
%% 
%% @spec handle_cast(Msg, State) -> {noreply, State} | 
%%                                  {noreply, State, Timeout} | 
%%                                  {stop, Reason, State} 
%% @end 
%%-------------------------------------------------------------------- 
handle_cast(stop, State) -> 
    {stop, ok, State}. 

%%--------------------------------------------------------------------                          
%% @private                                                                                     
%% @doc                                                                                         
%% Handling all non call/cast messages                                                          
%%                                                                                              
%% @spec handle_info(Info, State) -> {noreply, State} |                                         
%%                                   {noreply, State, Timeout} |                                
%%                                   {stop, Reason, State}                                      
%% @end                                                                                         
%%--------------------------------------------------------------------                          
handle_info({tcp, Socket, RawData}, State) -> 
    RequestCount = State#state.request_count, 
    try 
        Data         = string:strip( 
                         string:strip(RawData, right, $\n), 
                         right, $\r), 

        [M, F|Args] = string:tokens(Data, "|"), 
        Module      = list_to_atom(M), 
        Function    = list_to_atom(F), 
        Reply = 
        case Args of 
            []   -> Module:Function(); 
            Args -> Module:Function(Args) 
        end, 
case Reply of 
            ok -> 
                gen_tcp:send(Socket, "ok"); 
            {ok, Atom} when is_atom(Atom) -> 
                gen_tcp:send(Socket, atom_to_list(Atom)); 
            {ok, Integer} when is_integer(Integer) -> 
                gen_tcp:send(Socket, integer_to_list(Integer)); 
            {ok, [H|_] = String} when is_integer(H), H >= $\s, H < 255 -> 
                gen_tcp:send(Socket, String) 
        end 
    catch 
        _C:_E -> 
            gen_tcp:send(Socket, "error - call failed\n") 
    end, 
    {noreply, State#state{request_count = RequestCount + 1}}; 
handle_info(timeout, State) -> 
    {ok, _Sock} = gen_tcp:accept(State#state.lsock), 
    {noreply, State}.
    
%%--------------------------------------------------------------------                          
%% @private                                                                                     
%% @doc                                                                                         
%% This function is called by a gen_server when it is about to    
%% terminate. It should be the opposite of Module:init/1 and do any                                       
%% necessary cleaning up. When it returns, the gen_server terminates                                      
%% with Reason. The return value is ignored.                                                              
%%                                                                                                        
%% @spec terminate(Reason, State) -> void()                                                               
%% @end                                                                                                   
%%--------------------------------------------------------------------                                    
terminate(_Reason, _State) -> 
    ok. 
 
%%--------------------------------------------------------------------                                    
%% @private                                                                                               
%% @doc                                                                                                   
%% Convert process state when code is changed                                                             
%%                                                                                                        
%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}                                              
%% @end                                                                                                   
%%--------------------------------------------------------------------                                    
code_change(_OldVsn, State, _Extra) -> 
    {ok, State}. 

